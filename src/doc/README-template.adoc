= Java Code Generator Annotations

:INSTANTIATE: pass:quotes[link:./java-code-gen/src/main/java/com/kt/codegen/Instantiate.java[`@Instantiate`]]
:TRANSFORM:   pass:quotes[link:./java-code-gen/src/main/java/com/kt/codegen/Transform.java[`@Transform`]]
:REPLACE:     pass:quotes[link:./java-code-gen/src/main/java/com/kt/codegen/Replace.java[`@Replace`]]]
:SRC_DIR:     ../../java-code-gen-demo/src/main/java/com/kt/codegen/demo
:GEN_DIR:     ../../java-code-gen-demo/target/generated-sources/annotations/com/kt/codegen/demo


== TL;DR
=== What is this?
This library provides the following code-generating annotations:

* The {INSTANTIATE}
  annotation generates concrete instantiations of generic types analogous
  to C++ templates
* The {TRANSFORM}
  annotation can perform arbitrary code transformation using string replacements
  (plain or regex)

=== Why should I use it?
You may ask yourself: why not use a generic string template engine such as
link:https://www.stringtemplate.org/[StringTemplate],
link:https://velocity.apache.org/[Velocity]
or
link:https://freemarker.apache.org/[FreeMaker] instead? Because of one
fundamental advantage of this library:

*Your template is actual code*.

Instead of having to write a placeholder-sprinkled, engine-specific template file
your "template" is actual Java code, which means:

  ** The "template" is running code
  ** The "template" can be unit tested
  ** The "template" enjoys IDE syntax highlighting - no template
     engine-specific plugins required
  ** The "template" can be auto-formatted, linted and refactored by your IDE



== C++ Template Emulation

=== Motivation

Consider the following generic class (which, of course, would require a lot more work
before it's a reasonable list implementation):
[source,java]
----
include::{SRC_DIR}/list1/MyList.java[]
----

You can annotate it with {INSTANTIATE} to e.g. create a concrete String instantiation,
analogous to C++ templates:
[source,java]
----
include::{SRC_DIR}/list2/MyList.java[]
----

This will generate the following class:
[source,java]
----
include::{GEN_DIR}/list2/MyListString.java[]
----
Nice, but the annotation processor only operates on a source code level and simply
replaces occurrences of `T` with `String`. This leads to a guaranteed class cast
exception in the expression
`(String[]) new Object[size]` for array allocation. Can we fix this? Yes, with custom
string replacements, see below.


=== Custom String Replacements
Simply replacing a generic type with a concrete type like we just did doesn't usually
get us all the way, but fret not, there are custom string replacements:
[source,java]
----
include::{SRC_DIR}/list3/MyList.java[]
----

And our list compiles:
[source,java]
----
include::{GEN_DIR}/list3/MyListString.java[]
----

If simple string replacement won't do the trick you set `@Replace(..., regex = true)` for
matching regular expressions.


=== Primitives
How about adding a primitive version of our list? Simple: just add a `double` instantiation:
[source,java]
----
include::{SRC_DIR}/list4/MyList.java[]
----

This will generate the following class on top of `MyListString` from above:
[source,java]
----
include::{GEN_DIR}/list4/MyListDouble.java[]
----


=== Multiple Type Parameters
If your generic class has more than one type parameter then you'll simply have to provide
the necessary number of concrete types for each instantiation:
[source,java]
----
include::{SRC_DIR}/map/MyMap.java[]
----


=== Options
The following options allow for more flexibility:

* {INSTANTIATE}

  ** For projects that don't follow the maven directory layout you can specify the relative
     source folder with `relativeSourceDir`.
  ** I you prefer prepending the type to the class rather than the default appending variant
     (i.e., `StringMyList` rather than `MyListString` in the example above) then
     you can set `append` to `false`.

* {TRANSFORM}

  ** You can also change the `relativeSourceDir`

* {REPLACE}

  ** If normal string replacement won't cut it, you can set `regex` to
     `true`.



== Code Transformer
If you want to generate derived versions of a class but template instantiation is not the
right tool for the job, then the more generic
{TRANSFORM}
might do the trick.

Say you are working on a primitive collections library, and you have successfully written
a `double` list implementation:
[source,java]
----
include::{SRC_DIR}/double1/MyDoubleList.java[]
----

Now you have a couple of options to create lists for other primitive types:

. You copy and paste the class a couple of times followed by a search/replace frenzy. This
  is cumbersome, time-consuming and will eventually lead to implementations drifting
  apart because you'll forget to apply that fix to the `float` implementation.

. You fire up a generic template engine, convert this nice, working, unit-tested,
  syntax-highlighted, auto-formatted, error-checked class into a template text
  file that immediately loses all those nice properties, and you start configuring
  that template engine.

. Or you annotate your class as follows:

[source,java]
----
include::{SRC_DIR}/double2/MyDoubleList.java[]
----

This will generate two classes:
[source,java]
----
include::{GEN_DIR}/double2/MyFloatList.java[]
----

And:

[source,java]
----
include::{GEN_DIR}/double2/MyLongList.java[]
----
